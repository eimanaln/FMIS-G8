theory P2
begin

functions:
  mac/2, verify/3, true/0
equations:
  verify(k, m, mac(m, k)) = true

rule Register_key:
  [ Fr(~k) ]

  --[ Register($A, $B, ~k) ]->

  [ !SharedKey($A, $B, ~k) ]


rule Reveal_key:
  [ !SharedKey(A, B, k) ]

  --[ Reveal(A, B) ]->

  [ Out(k) ]


rule Init_A:
  [ Fr(~idA), !SharedKey(A, B, kab) , !SharedKey(B, A, kba)]

  --[ Init_A(A, ~idA) ]->

  [ St_A_1(A, ~idA, kab, B, kba) ]


rule Init_B:
  [ Fr(~idB), !SharedKey(A, B, kab), !SharedKey(B, A, kba) ]

  --[ Init_B(B, ~idB) ]->

  [ St_B_1(B, ~idB, kba, A, kab) ]


rule A_1_send:
  [ Fr(~x), St_A_1(A, ~idA, kab, B, kba) ]

  --[ Send(A, ~x) ]->

  [ St_A_2(A, ~idA, kab, B, kba, ~x), Out(~x) ]


rule B_1_recv:
  [ St_B_1(B, ~idB, kba, A, kab), In(x) ]

  --[ Recv(B, x) ]->

  [ St_B_2(B, ~idB, kba, A, kab, x) ]


rule B_2_send:
  [ Fr(~y), St_B_2(B, ~idB, kba, A, kab, x) ]

  --[ Send(B, ~y) ]->

  [ St_B_3(B, ~idB, kba, A, kab, x, ~y), Out(~y) ]


rule A_2_recv:
  [ St_A_2(A, ~idA, kab, B, kba, x), In(y) ]

  --[ Recv(A, y) ]->

  [ St_A_3(A, ~idA, kab, B, kba, x, y) ]


rule B_3_send:
  [ St_B_3(B, ~idB, kba, A, kab, x, y) ]

  --[ Send(B, mac(x, kba)) ]->

  [ St_B_4(B, ~idB, kba, A, kab, x, y, mac(x, kba)), Out(mac(x, kba)) ]


rule A_3_recv:
  [ St_A_3(A, ~idA, kab, B, kba, x, y), In(mac(x,kba)) ]

  --[ Recv(A, mac(x,kba)) ]->

  [ St_A_4(A, ~idA, kab, B, kba, x, y, mac(x,kba)) ]


rule A_4_send:
  [ St_A_4(A, ~idA, kab, B, kba, x, y, mac(x,kba)) ]

  --[ Send(A, mac(y, kab)) ]->

  [ St_A_5(A, ~idA, kab, A, kba, x, y, mac(x, kba), mac(y,kab)), Out(mac(y, kab)) ]


rule B_4_recv:
  [ St_B_4(B, ~idB, kba, A, kab, x, y, mac(x,kba)), In(mac(y,kab)) ]

  --[ Recv(B, mac(x,kba)), Commit(A, B, <'I','R',x>), Finish() ]->

  [ St_B_5(B, ~idB, kba, A, kab, x, y, mac(x,kba), mac(y,kab)) ]


lemma UnidirectionalKey:
  " All a b k1 k2 #i #j.
      not (a = b) & Register(a, b, k1)@i & Register(b, a, k2)@j ==> not (k1 = k2)"

lemma executable_restricted: exists-trace
  " Ex #i.
      Finish() @i &
      not (Ex I1 I2 id1 id2 #j #k. Init_A(I1, id1)@j & Init_A(I2, id2)@k & not (#j = #k)) &
      not (Ex I1 I2 id1 id2 #j #k. Init_B(I1, id1)@j & Init_B(I2, id2)@k & not (#j = #k)) &
      not (Ex A B #j. Reveal(A, B)@j)"

lemma executable: exists-trace
  " Ex #i.
      Finish() @i &
      not (Ex I1 I2 id1 id2 #j #k. Init_A(I1, id1)@j & Init_A(I2, id2)@k & not (#j = #k)) &
      not (Ex A B #j. Reveal(A, B)@j)"

lemma noninjectiveagreementINITIATOR:
  " All A B t #i.
      Commit(A,B,<'I','R',t>)@i &
      not ((Ex #r. Reveal(A,B)@r) | (Ex #r. Reveal(B,A)@r))
        ==> (Ex #j. Running(B,A,<'I','R',t>)@j)"

lemma injectiveagreementINITIATOR:
  " All A B t #i.
      Commit(A,B,<'I','R',t>)@i &
      not ((Ex #r. Reveal(A,B)@r) | (Ex #r. Reveal(B,A)@r))
      ==> (Ex #j. Running(B,A,<'I','R',t>)@j
        & not (Ex a2 b2 #i2. Commit(a2,b2,<'I','R',t>)@i2
          & not (#i2 = #i)))"

// restrict to get simpler attacks
restriction one_A_at_most:
  " not (Ex Name1 Id1 Name2 Id2 #i #j. Init_A(Name1, Id1) @i & Init_A(Name2, Id2) @j & not (#i = #j)) "

restriction one_B_at_most:
  " not (Ex Name1 Id1 Name2 Id2 #i #j. Init_B(Name1, Id1) @i & Init_B(Name2, Id2) @j & not (#i = #j)) "


end
