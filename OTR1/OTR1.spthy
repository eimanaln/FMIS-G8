theory OTR1
begin

builtins: signing, diffie-hellman

rule Register_key:
  [ Fr(~k) ] --[ Register($A, ~k), Reg_() ]-> [ !Ltk($A, ~k), !Pk($A, pk(~k)), Out(pk(~k)) ]

rule Reveal_key:
  [ !Ltk(A, k) ] --[ Reveal(A) ]-> [ Out(k) ]


rule Init_A:
  [ Fr(~idA), !Ltk(A, ka), !Pk(B, pkb) ]

  --[ Init('I', A, ~idA, B), Init2('I') ]->

  [ St_A_1(A, B, ~idA, ka, pkb) ]


rule Init_B:
  [ Fr(~idB), !Pk(A, pka), !Ltk(B, kb) ]

  --[ Init('R', B, ~idB, A), Init2('R')]->

  [ St_B_1(A, B, ~idB, pka, kb) ]


rule A_1_send:
  let gx = 'g'^~x
      signgx = sign(gx, ka)
  in
  [ St_A_1(A, B, idA, ka, pkb), Fr(~x) ]

  --[ Send(A, signgx),  ]->

  [ St_A_2(A, B, idA, ka, pkb, ~x), Out(<gx, signgx, pk(ka)>) ]


rule B_1_recv:
  [ St_B_1(A, B, idB, pka, kb), In(<gx, signgx, pka>) ]

  --[ Recv(B, signgx), _restrict(verify(signgx, gx, pka) = true) ]->

  [ St_B_2(A, B, idB, pka, kb, gx) ]


rule B_2_send:
  let gy = 'g'^~y
      signgy = sign(gy, kb)
  in
  [ St_B_2(A, B, idB, pka, kb, gx), Fr(~y) ]

  --[ Send(B, signgy), Running(B, A, <'I','R', gx, gy>) ]->

  [ St_B_3(A, B, idB, pka, kb, gx, ~y), Out(<gy, signgy, pk(kb)>) ]


rule A_2_recv:
  [ St_A_2(A, B, idA, ka, pkb, x), In(<gy, signgy, pkb>) ]

  --[ Recv(B, signgy), _restrict(verify(signgy, gy, pkb) = true),
      Commit(A, B, <'I','R', 'g'^x, gy>), Finish() ]->

  [ St_A_3(A, B, idA, ka, pkb, x, gy) ]


lemma executable: exists-trace
  " Ex #i.
      Finish() @i &
      (Ex #i. Init2('I')@i) &
      (Ex #i. Init2('R')@i) &
      not (Ex A #j. Reveal(A)@j)"

restriction two_k_at_most:
  " All #i #j #k. Reg_()@i & Reg_()@j & Reg_()@k ==> (#i=#j|#i=#k|#j=#k) "

restriction three_inits_at_most:
  " All R1 R2 R3 R4 #i #j #k #l. Init2(R1)@i & Init2(R2)@j & Init2(R3)@k & Init2(R4)@l
    ==> (#i=#j|#i=#k|#i=#l|#j=#k|#j=#l|#k=#l)
  "
restriction no_selftalk:
  " All R A id B #i. Init(R, A, id, B)@i ==> not (A=B) "

end
