theory P2b
begin

functions:
  mac/2, verify/3, true/0
equations:
  verify(k, m, mac(m, k)) = true

rule Register_key:
  [ Fr(~k) ]

  --[ Register($A, $B, ~k), RegisteredSomeKey() ]->

  [ !SharedKey($A, $B, ~k) ]


rule Reveal_key:
  [ !SharedKey(A, B, k) ]

  --[ Reveal(A), Reveal(B) ]->

  [ Out(k) ]


rule Init_A:
  [ Fr(~idA), !SharedKey(A, B, kab) , !SharedKey(B, A, kba) ]

  --[ Init('I', A, ~idA), InitRole('I') ]->

  [ St_A_1(A, B, ~idA, kab, kba) ]


rule Init_B:
  [ Fr(~idB), !SharedKey(A, B, kab), !SharedKey(B, A, kba) ]

  --[ Init('R', B, ~idB), InitRole('R') ]->

  [ St_B_1(A, B, ~idB, kab, kba) ]


rule A_1_send:
  [ St_A_1(A, B, idA, kab, kba), Fr(~x) ]

  --[ Send(A, ~x) ]->

  [ St_A_2(A, B, idA, kab, kba, ~x), Out(~x) ]


rule B_1_recv:
  [ St_B_1(A, B, idB, kab, kba), In(x) ]

  --[ Recv(B, x) ]->

  [ St_B_2(A, B, idB, kab, kba, x) ]


rule B_2_send:
  [ St_B_2(A, B, idB, kab, kba, x), Fr(~y) ]

  --[ Send(B, ~y), Running(B,A,<'I','R',x,~y>) ]->

  [ St_B_3(A, B, idB, kab, kba, x, ~y), Out(~y) ]


rule A_2_recv:
  [ St_A_2(A, B, idA, kab, kba, x), In(y) ]

  --[ Recv(A, y), Running(A,B,<'R','I',x,y>) ]->

  [ St_A_3(A, B, idA, kab, kba, x, y) ]


rule B_3_send:
  [ St_B_3(A, B, idB, kab, kba, x, y) ]

  --[ Send(B, mac(x,kba)) ]->

  [ St_B_4(A, B, idB, kab, kba, x, y), Out(mac(<x,y>,kba)) ]


rule A_3_recv:
  [ St_A_3(A, B, idA, kab, kba, x, y), In(macxy) ]

  --[ Recv(A, macxy), _restrict(verify(kba, <x,y>, macxy) = true) ]->

  [ St_A_4(A, B, idA, kab, kba, x, y) ]


rule A_4_send:
  [ St_A_4(A, B, idA, kab, kba, x, y) ]

  --[ Send(A, mac(y,kab)), Commit(A,B,<'I','R',x,y>) ]->

  [ St_A_5(A, B, idA, kab, kba, x, y), Out(mac(y,kab)) ]


rule B_4_recv:
  [ St_B_4(A, B, idB, kab, kba, x, y), In(macy) ]

  --[ Recv(B, macy), Finish(), Commit(B,A,<'R','I',x,y>), _restrict(verify(kab, y, macy) = true) ]->

  [ St_B_5(A, B, idB, kab, kba, x, y) ]


lemma UnidirectionalKey:
  " All a b k1 k2 #i #j.
      not (a = b) & Register(a, b, k1)@i & Register(b, a, k2)@j ==> not (k1 = k2)
      "
lemma executable: exists-trace
  " Ex #i. Finish()@i &
    not (Ex R A B id1 id2 #i #j. Init(R, A, id1)@i & Init(R, B, id2)@j & not (#i = #j)) &
    not (Ex A #i. Reveal(A)@i)
    "
lemma noninjectiveagreementINITIATOR:
  " All A B t #i.
      Commit(A,B,<'I','R',t>)@i &
        not ((Ex #r. Reveal(A)@r) | (Ex #r. Reveal(B)@r))
      ==> (Ex #j. Running(B,A,<'I','R',t>)@j)
      "
lemma injectiveagreementINITIATOR:
  " All A B t #i.
      Commit(A,B,<'I','R',t>)@i &
        not ((Ex #r. Reveal(A)@r) | (Ex #r. Reveal(B)@r))
      ==> (Ex #j. Running(B,A,<'I','R',t>)@j
        & not (Ex a2 b2 #i2. Commit(a2,b2,<'I','R',t>)@i2
          & not (#i2 = #i)))
          "
lemma noninjectiveagreementRESPONDER:
  " All A B t #i.
      Commit(A,B,<'R','I',t>)@i &
        not ((Ex #r. Reveal(A)@r) | (Ex #r. Reveal(B)@r))
      ==> (Ex #j. Running(B,A,<'R','I',t>)@j)
      "
lemma injectiveagreementRESPONDER:
  " All A B t #i.
      Commit(A,B,<'R','I',t>)@i &
        not ((Ex #r. Reveal(A)@r) | (Ex #r. Reveal(B)@r))
      ==> (Ex #j. Running(B,A,<'R','I',t>)@j
        & not (Ex a2 b2 #i2. Commit(a2,b2,<'R','I',t>)@i2
          & not (#i2 = #i)))
          "

// restrict to get simpler attacks
restriction three_initiators_at_most:
  " All #i #j #k #l. InitRole('I')@i & InitRole('I')@j & InitRole('I')@k & InitRole('I')@l
      ==> (#i=#j|#i=#k|#i=#l|#j=#k|#j=#l|#k=#l)
      "
end
