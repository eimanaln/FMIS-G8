theory Oliver
begin


functions:
  mac/2, verify/3, true/0, kdf/3
equations:
  verify(k, m, mac(m, k)) = true

rule Register_key:
  [ Fr(~k) ]
  -->
  [ !SharedKey($A, $B, ~k) ]

/*----------------------------------------*/


rule Reveal_key_A:
  [ !SharedKey(A, B, k) ]

  --[ Reveal(A) ]->

  [ Out(k) ]

  rule Reveal_key_B:
  [ !SharedKey(A, B, k) ]

  --[ Reveal(B) ]->

  [ Out(k) ]

/*----------------------------------------*/


rule Init_A:
  [ Fr(~idA), !SharedKey(A, B, k) ]

  --[ Init('I', A, ~idA) ]->

  [ St_A_1(A, B, ~idA, k) ]


rule Init_B:
  [ Fr(~idB), !SharedKey(A, B, k) ]

  --[ Init('R', B, ~idB)]->

  [ St_B_1(A, B, ~idB, k) ]

/*----------------------------------------*/

rule A_1_send:
  [ St_A_1(A, B, idA, k), Fr(~x) ]

  --[ Send(A, ~x) ]->

  [ St_A_2(A, B, idA, k, ~x), Out(~x) ]


rule B_1_recv:
  [ St_B_1(A, B, idB, k), In(x) ]

  --[ Recv(B, x) ]->

  [ St_B_2(A, B, idB, k, x) ]


rule B_2_send:
  [ St_B_2(A, B, idB, k, x), Fr(~y) ]

  --[ Send(B, ~y) ]->

  [ St_B_3(A, B, idB, k, x, ~y), Out(~y) ]


rule A_2_recv:
  [ St_A_2(A, B, idA, k, x), In(y) ]

  --[ Recv(A, y) ]->

  [ St_A_3(A, B, idA, k, x, y) ]



rule A_3_send:
  let dk = kdf(k,x,y)
      macy = mac(y,dk)
  in
  [ St_A_3(A, B, idA, k, x, y) ]

  --[ Send(A, macy), Running(A,B,<'R','I',x,y, dk>)]->

  [ St_A_4(A, B, idA, k, x, y), Out(macy) ]


rule B_3_recv:
  let dk = kdf(k,x,y)
  in
  [ St_B_3(A, B, idB, k, x, y), In(macy) ]

  --[ Recv(B, macy),_restrict(verify(dk, y, macy) = true), Running(B,A,<'I','R',x,y, dk>) ]->

  [ St_B_4(A, B, idB, k, x, y) ]



rule B_4_send:
  let dk = kdf(k,x,y)
      macx = mac(x,dk)
  in
  [ St_B_4(A, B, idB, k, x, y) ]

  --[ Send(B, macx), 
      Finish(B, A, 'R', x, y, dk), 
      Commit(B,A,<'R','I',x,y, dk>), 
      Secret(B,A,dk) ]->

  [ St_B_5(A, B, idB, k, x, y), Out(macx) ]


rule A_4_recv:
  let dk = kdf(k,x,y)
  in
  [ St_A_3(A, B, idA, k, x, y), In(macx) ]

  --[ Commit(A,B,<'I','R',x,y, dk>), 
      Secret(A,B,dk),
      Recv(A, macx), 
      _restrict(verify(dk, x, macx) = true), 
      Finish(A, B, 'I', x, y, dk) ]->

  [ St_A_5(A, B, idA, k, x, y) ]



lemma executable: 
exists-trace
  " Ex A B x y k #i #j.
      Finish(B, A, 'R', x, y, k) @i 
        & Finish(A, B, 'I',x, y, k) @j 
          & not (Ex R A B id1 id2 #i #j. Init(R, A, id1)@i & Init(R, B, id2)@j & not (#i = #j))
            & not(Ex X #k. Reveal(X)@k)
    "

lemma injectiveagreementINITIATOR:
  " All A B t #i.
      Commit(A,B,<'I','R',t>)@i &
        not ((Ex #r. Reveal(A)@r) | (Ex #r. Reveal(B)@r))
      ==> (Ex #j. Running(B,A,<'I','R',t>)@j
        & not (Ex a2 b2 #i2. Commit(a2,b2,<'I','R',t>)@i2
          & not (#i2 = #i)))
          "

lemma injectiveagreementRESPONDER:
  " All A B t #i.
      Commit(A,B,<'R','I',t>)@i &
        not ((Ex #r. Reveal(A)@r) | (Ex #r. Reveal(B)@r))
      ==> (Ex #j. Running(B,A,<'R','I',t>)@j
        & not (Ex a2 b2 #i2. Commit(a2,b2,<'R','I',t>)@i2
          & not (#i2 = #i)))
          "

lemma secrecy:
  " All A B x #i.
      Secret(A,B,x)@i &
        not ((Ex #r. Reveal(A)@r) | (Ex #r. Reveal(B)@r))
      ==> not (Ex #j. K(x)@j)
      "
end