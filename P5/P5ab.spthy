theory P5ab
begin

builtins: hashing, symmetric-encryption, diffie-hellman

functions:
  mac/2, verify/3, true/0, map/2
equations:
  verify(k, m, mac(m, k)) = true

rule Register_key:
  [ Fr(~k) ]

  --[ Register($A, $B, ~k) ]->

  [ !SharedKey($A, $B, ~k) ]


rule Reveal_key:
  [ !SharedKey(A, B, k) ]

  --[ Reveal(A,B) ]->

  [ Out(k) ]


rule Init_A:
  [ Fr(~idA), !SharedKey(A, B, k) ]

  --[ Init_A(A, ~idA) ]->

  [ St_A_1(A, B, ~idA, k) ]


rule Init_B:
  [ Fr(~idB), !SharedKey(A, B, k) ]

  --[ Init_B(B, ~idB) ]->

  [ St_B_1(A, B, ~idB, k) ]


rule A_1_send:
  let g = map(~s, $p)
  in
  [ St_A_1(A, B, idA, k), Fr(~x), Fr(~s) ]

  --[ Send(A, <$p, g^~x, senc(~s,h(k))>) ]->

  [ St_A_2(A, B, idA, k, ~s, $p ,~x), Out(<$p, g^~x, senc(~s, h(k))>) ]


rule B_1_recv:
  let gx = map(s,p)^x // match to avoid DH_neutral
  in
  [ St_B_1(A, B, idB, k), In(<p, gx, senc(s,h(k))>) ]

  --[ Recv(B, <p,gx,senc(s,h(k))>) ]->

  [ St_B_2(A, B, idB, k, s, p, gx) ]


rule B_2_send:
  let g = map(s,p)
  in
  [ St_B_2(A, B, idB, k, s, p, gx), Fr(~y) ]

  --[ Send(B, g^~y), Running(B,A,<'I','R',gx,g^~y>) ]->

  [ St_B_3(A, B, idB, k, s, p, gx, ~y), Out(g^~y) ]


rule A_2_recv:
  let g = map(s,p)
      gy = g^y // match to avoid DH_neutral
  in
  [ St_A_2(A, B, idA, k, s, p, x), In(gy) ]

  --[ Recv(A, gy), Running(A,B,<'R','I',g^x,gy>) ]->

  [ St_A_3(A, B, idA, k, s, p, x, gy) ]


rule B_3_send:
  let dk = h(gx^y)
      macx = mac(gx,dk)
  in
  [ St_B_3(A, B, idB, k, s, p, gx, y) ]

  --[ Send(B, macx), TB() ]->

  [ St_B_4(A, B, idB, k, s, p, gx, y, macx), Out(macx) ]


rule A_3_recv:
  let dk = h(gy^x)
      g = map(s,p)
      macx = mac(g^x,dk)
  in
  [ St_A_3(A, B, idA, k, s, p, x, gy), In(macx) ]

  --[ Recv(A, macx), TA() ]->

  [ St_A_4(A, B, idA, k, s, p, x, gy, macx) ]


rule A_4_send:
  let dk = h(gy^x)
      macy = mac(gy,dk)
      g = map(s,p)
  in
  [ St_A_4(A, B, idA, k, s, p, x, gy, macx) ]

  --[ Send(A, macy), Commit(A,B,<'I','R',g^x,gy>), Secret(A,B,dk) ]->

  [ St_A_5(A, B, idA, k, s, p, x, gy, macx), Out(macy) ]


rule B_4_recv:
  let g = map(s,p)
      dk = h(gx^y)
      macy = mac(g^y,dk)
  in
  [ St_B_4(A, B, idB, k, s, p, gx, y, macx), In(macy) ]

  --[ Recv(B, macy), Finish(), Commit(B,A,<'R','I',gx,g^y>), Secret(B,A,dk) ]->

  [ St_B_5(A, B, idB, k, s, p, gx, y, macx) ]


lemma executable: exists-trace
  // " Ex #i1 #i2.
  //     TA() @i1 & TB() @i2 &
  " Ex #i.
      Finish() @i &
      // not (Ex I1 I2 id1 id2 #j #k. Init_A(I1, id1)@j & Init_A(I2, id2)@k & not (#j = #k)) &
      // not (Ex I1 I2 id1 id2 #j #k. Init_B(I1, id1)@j & Init_B(I2, id2)@k & not (#j = #k)) &
      not (Ex A B #j. Reveal(A, B)@j)"

lemma noninjectiveagreementINITIATOR:
  " All A B t #i.
      Commit(A,B,<'I','R',t>)@i &
        not ((Ex #r. Reveal(A,B)@r) | (Ex #r. Reveal(B,A)@r))
      ==> (Ex #j. Running(B,A,<'I','R',t>)@j)"

lemma injectiveagreementINITIATOR:
  " All A B t #i.
      Commit(A,B,<'I','R',t>)@i &
        not ((Ex #r. Reveal(A,B)@r) | (Ex #r. Reveal(B,A)@r))
      ==> (Ex #j. Running(B,A,<'I','R',t>)@j
        & not (Ex a2 b2 #i2. Commit(a2,b2,<'I','R',t>)@i2
          & not (#i2 = #i)))"

lemma noninjectiveagreementRESPONDER:
  " All A B t #i.
      Commit(A,B,<'R','I',t>)@i &
        not ((Ex #r. Reveal(A,B)@r) | (Ex #r. Reveal(B,A)@r))
      ==> (Ex #j. Running(B,A,<'R','I',t>)@j)"

lemma injectiveagreementRESPONDER:
  " All A B t #i.
      Commit(A,B,<'R','I',t>)@i &
        not ((Ex #r. Reveal(A,B)@r) | (Ex #r. Reveal(B,A)@r))
      ==> (Ex #j. Running(B,A,<'R','I',t>)@j
        & not (Ex a2 b2 #i2. Commit(a2,b2,<'R','I',t>)@i2
          & not (#i2 = #i)))"

lemma secrecy:
  " All A B x #i.
      Secret(A,B,x)@i &
        not ((Ex #r. Reveal(A,B)@r) | (Ex #r. Reveal(B,A)@r))
      ==> not (Ex #j. K(x)@j)"

// restrict to get simpler attacks
restriction one_A_at_most:
  " not (Ex Name1 Id1 Name2 Id2 #i #j. Init_A(Name1, Id1) @i & Init_A(Name2, Id2) @j & not (#i = #j)) "

restriction one_B_at_most:
  " not (Ex Name1 Id1 Name2 Id2 #i #j. Init_B(Name1, Id1) @i & Init_B(Name2, Id2) @j & not (#i = #j)) "

restriction one_k_at_most:
  " not (Ex Name1 Name2 k1 k2 #i #j. Register(Name1, Name2, k1) @i & Register(Name1, Name2, k2) @j & not (#i = #j)) "

end
